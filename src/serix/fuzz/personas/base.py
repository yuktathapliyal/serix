"""Base classes and types for Attack Personas."""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

from serix.core.config_loader import get_models

if TYPE_CHECKING:
    from openai import OpenAI


@dataclass
class PersonaConfig:
    """Configuration for an attack persona.

    Attributes:
        name: Human-readable name for the persona
        description: Brief description of the persona's attack strategy
        model: LLM model to use (default: from serix.toml [models].attacker)
        temperature: Sampling temperature for creativity (default: 0.9)
        max_tokens: Maximum tokens for generated attacks (default: 500)
    """

    name: str
    description: str
    model: str | None = None  # Resolved to config in AttackPersona.__init__
    temperature: float = 0.9  # High for creativity
    max_tokens: int = 500


@dataclass
class AttackContext:
    """Context passed to a persona for attack generation.

    Contains all information the persona needs to generate an adaptive attack,
    including the goal, current turn, conversation history, and critic feedback.

    Attributes:
        goal: The attacker's objective (e.g., "reveal API keys")
        turn: Current turn number (1-indexed)
        conversation_history: List of {"role": "...", "content": "..."} dicts
        previous_attempts: List of previous attack payloads tried
        critic_feedback: Feedback from the Critic about the last attempt
    """

    goal: str
    turn: int
    conversation_history: list[dict] = field(default_factory=list)
    previous_attempts: list[str] = field(default_factory=list)
    critic_feedback: str | None = None


@dataclass
class AttackPayload:
    """An attack payload generated by a persona.

    Attributes:
        content: The actual attack string to send to the target
        technique: Name of the technique used (e.g., "DAN", "grandma_exploit")
        reasoning: Optional internal reasoning (not sent to target)
    """

    content: str
    technique: str
    reasoning: str | None = None


class AttackPersona(ABC):
    """Abstract base class for attack personas.

    Personas specialize in particular attack strategies (jailbreaking, data
    extraction, confusion, etc.) and adapt based on agent responses using
    LLM-generated attacks rather than static templates.
    """

    def __init__(self, client: "OpenAI", config: PersonaConfig) -> None:
        """Initialize the persona.

        Args:
            client: OpenAI client for generating attacks (should be unpatched)
            config: Configuration for the persona
        """
        self.client = client
        self.config = config
        # Resolve model from config, store as guaranteed-string instance var
        self._model: str = config.model or get_models().attacker
        self._attack_count = 0

    @property
    def name(self) -> str:
        """Return the persona's name."""
        return self.config.name

    @property
    def description(self) -> str:
        """Return the persona's description."""
        return self.config.description

    @abstractmethod
    def generate_attack(self, context: AttackContext) -> AttackPayload:
        """Generate the next attack payload based on context.

        This is the core method that each persona must implement. The persona
        should analyze the context (especially critic_feedback) and adapt its
        strategy accordingly.

        Args:
            context: Current attack context with goal, history, and feedback

        Returns:
            AttackPayload with the attack content and technique name
        """
        pass

    @abstractmethod
    def get_system_prompt(self) -> str:
        """Return the persona's system prompt for the attack LLM.

        This defines the persona's "character" and attack strategy. The prompt
        should instruct the LLM to output only the attack, no explanations.

        Returns:
            System prompt string for the attack generation LLM
        """
        pass

    def get_techniques(self) -> list[str]:
        """Return list of attack techniques this persona can use.

        Override this to enumerate the specific techniques available.
        Used for reporting and strategy selection.

        Returns:
            List of technique names (e.g., ["DAN", "developer_mode", "grandma"])
        """
        return []

    def reset(self) -> None:
        """Reset persona state between attack sessions.

        Called before starting a new attack against a target to ensure
        clean state. Override if the persona maintains additional state.
        """
        self._attack_count = 0

    def _call_llm(self, system_prompt: str, user_prompt: str) -> str:
        """Helper to call the LLM for attack generation.

        Args:
            system_prompt: System prompt defining persona behavior
            user_prompt: User prompt with attack context

        Returns:
            Generated attack string
        """
        response = self.client.chat.completions.create(
            model=self._model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt},
            ],
            temperature=self.config.temperature,
            max_tokens=self.config.max_tokens,
        )
        return response.choices[0].message.content or ""
